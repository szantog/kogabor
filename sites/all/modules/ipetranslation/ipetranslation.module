<?php
// $Id: ipetranslation.module,v 1.8 2010/02/26 09:10:15 khorpyakov Exp $

function _ipetranslation_prepare_teaser(&$node_translated, $node = NULL) {
	if ($node == NULL) {
		$node = $node_translated;
	}
	foreach (array('_js', '_include') as $suffix) {
        $teaser_field_name = 'teaser_' . $node_translated->language . $suffix;		
        if (isset($node->$teaser_field_name)) {
            $node_translated->{'teaser' . $suffix} = $node->$teaser_field_name;
        }
	}
    // Excerpt from node.module
    if (!isset($node->{'teaser_' . $node_translated->language})) {
	    if (isset($node_translated->body)) {
	        $node_translated->teaser = node_teaser($node_translated->body, isset($node_translated->format) ? $node_translated->format : NULL);
	        // Chop off the teaser from the body if needed. The teaser_include
	        // property might not be set (eg. in Blog API postings), so only act on
	        // it, if it was set with a given value.
	        if (isset($node_translated->teaser_include) && !$node_translated->teaser_include && $node_translated->teaser == substr($node_translated->body, 0, strlen($node_translated->teaser))) {
	            $node_translated->body = substr($node_translated->body, strlen($node_translated->teaser));
	        }
	    }
	    else {
	        $node_translated->teaser = '';
	        $node_translated->format = 0;
	    }
    }	
}

/**
 * Implementation of hook_nodeapi().
 * 
 * Clone/update content for every language enabled
 */
function ipetranslation_nodeapi(&$node, $op) {
	global $i18nsync;
	
	$fields = ipetranslation_node_fields($node->type);
	
	
	// Check if there are ipetranslation-enabled fields for node type
    if (!translation_supported_type($node->type) or (count($fields) == 0)) {
        return;        		
    }

    // Avoid programmaticlly-submitted node saves/updates
    // with exception for delete operations
    // or use force_ipetranslation for special cases
    if ((!$node->force_ipetranslation) and ((!$node->form_build_id or !$node->form_token) and ($op != 'delete'))) {
    	return; 
    }
	
	switch ($op) {
		case 'presave':
  			// Force default language to be set for nodes supporting translation and In-place translation fields enabled
  			if (empty($node->language)) {  				
  				$node->language = i18n_get_lang();
  			}
			break;		
				
		case 'insert':
			// Only act if we are dealing with a content type supporting translations
		  	if (!empty($node->tnid)) {
    			return;
  			}

            // Retireve CCK info
            $ref_fields = array();
            if (module_exists('content')) {
                $type_fields = content_fields(NULL, $node->type);
                
                foreach($type_fields as $field_name => $field_description) {
                	if ($field_description['type'] == 'nodereference') {
                		$ref_fields[$field_name] = TRUE;
                	}
                }
            } 
  			
  			// Set translation source reference to itself
  			db_query("UPDATE {node} SET tnid = %d, translate = %d WHERE nid = %d", $node->nid, 0, $node->nid);  			
			// Populate languages
			$languages = i18n_node_language_list($node, true);			
			// For each active language create a translated node copy
			foreach (array_keys($languages) as $lang) {
				if (($node->language != $lang) and ($lang != '')) {
					$node_translated = clone $node;
					$node_translated->language = $lang;
				 	$node_translated->tnid = $node->nid;				 	
				 	// per language fields
      				foreach ($fields as $field) {
      					$node_translated->$field = $node_translated->{$field . '_' . $node_translated->language};
      					// Attach summary for body field
      					if ($field == 'body') {
      						unset($node_translated->teaser);
      						_ipetranslation_prepare_teaser($node_translated);
                        }      						
      				}
      				// Update CCK reference fields with apropriate translations
                    foreach ($ref_fields as $field => $value) {
                    	i18nsync_node_translation_nodereference_field($node, $node_translated, $field);
                    }      				
					unset($node_translated->nid);
					node_save($node_translated);
				}
			}
			break;
			
		case 'update':
			// Check if we have already processed this node
			if (($node->ipetranslated)) {
    			return;
  			}			
			// Populate translations
			$translations = translation_node_get_translations($node->tnid);
			if (is_array($translations)) {			
				// Prevent i18nsync module from redundant synchronization
				$i18nsync = TRUE;
				// For each active language update a translated node copy
				foreach (array_keys($translations) as $tlang) {
					if ($node->nid != $translations[$tlang]->nid) {
						$node_translated = node_load($translations[$tlang]->nid);
	      				foreach ($fields as $field) {
	      					if (isset($node->{$field . '_' . $node_translated->language})) {
	                            $node_translated->{$field} = $node->{$field . '_' . $node_translated->language};
	      					}
                            // Attach summary for body field
                            if ($field == 'body') {
                                _ipetranslation_prepare_teaser($node_translated, $node);
                            }                           
	      				}      				
	      				// Prevent recursive call by setting flag
	      				$node_translated->ipetranslated = TRUE;
	      				node_save($node_translated);
	      				// Reset cache
	      				node_load($translations[$tlang]->nid, null, true);				   				
					}
				}
				$i18nsync = FALSE;
			}
			break;
			
		case 'delete':
			if (variable_get('translation_delete_at_once_' . $node->type, 0) and !$i18nsync) {				
				// Flag to avoid recursive loop
			    $i18nsync = TRUE;				
				// Delete translations
				$translations = translation_node_get_translations($node->tnid);
				if (is_array($translations)) {
	                foreach (array_keys($translations) as $tlang) {
	                	if ($node->nid != $translations[$tlang]->nid) {
	                		node_delete($translations[$tlang]->nid);                      
	                	}
	                }
				}
				$i18nsync = FALSE;
			}
			break;
	}
}

/**
 * Implementation of hook_locale()
 */
function ipetranslation_locale($op = 'groups', $group = NULL) {
	switch ($op) {
		case 'groups':
			return array('ipetype' => t('In-place Translation fields'));
			
		case 'refresh':
			 if ($group == 'ipetype') {
			 	return _ipetranslation_locale_refresh();
			 }
			 
		default:
			return FALSE;
	}
}

/**
 * Create locale strings for title and body labels of in-place translation fields
 */
function _ipetranslation_locale_refresh() {
	$languages = i18n_language_list();
	
	foreach (node_get_types() as $type) {
		if (translation_supported_type($type->type)) {
			foreach (ipetranslation_node_fields($type->type) as $field) {
                foreach ($languages as $language => $language_title) {
                	switch ($field) {
					   case 'title':
					   	   tt("nodetype:type:$type->type:title_$language", $type->title_label.' on '.$language_title, NULL, TRUE);              
    					   break;					
	   				    case 'body':
                           tt("nodetype:type:$type->type:body_$language", $type->body_label.' on '.$language_title, NULL, TRUE);              
                           break;                            
                        default:
                            ; // TODO: Add CCK support
				    	break;
                	}
                }				
			}					
		}
	}
}

/**
 * Implementation of hook_form_node_type_form_alter().
 * 
 * Add special workflow section: In-place translation. Select fields
 * for which in-place translation should be activated
 */
function ipetranslation_form_node_type_form_alter(&$form, $form_state) {
	$type = $form['#node_type']->type;
	$current = ipetranslation_node_fields($type);
            
    $form['workflow']['ipetranslation'] = array(
        '#type' => 'fieldset',
        '#tree' => TRUE,
        '#title' => t('Expand translation'),
        '#collapsible' => TRUE,
        '#weight' => 4,
        '#collapsed' => !count($current),
        '#description' => t('Select which fields should be supplemented with input fields for other languages.')
    );
    // Each set provides title and options. We build a big checkboxes control 
    // for it to be saved as an array. Special themeing for group titles.
    foreach (ipetranslation_node_available_fields($type) as $group => $data) {
    	$title = $data['#title'];
    	if (!empty($data['#options'])) {
    		foreach ($data['#options'] as $field => $name) {
    			$form['workflow']['ipetranslation'][$field] = array(
    			     '#group_title' => $title,
    			     '#title' => $name,
    			     '#type' => 'checkbox',
    			     '#default_value' => in_array($field, $current),
    			);
    			$title = '';
    		}
    	}
    }

    // Delete at once node with translations
    $form['workflow']['translation_delete_at_once'] = array(
        '#title' => t('Delete at once'),
        '#type' => 'checkbox',
        '#weight' => 5,
        '#default_value' => variable_get('translation_delete_at_once_' . $type, 0),
        '#description' => t('Deleting original node or any of the translations triggers deletion of other translations and original itself.'),    
    );    
}

/**
 * Implementation of hook_form_alter().
 * 
 * Add form fields for simultaneous input for every enabled language
 */
function ipetranslation_form_alter(&$form, $form_state, $form_id) {
	
	if (translation_supported_type($form['#node']->type)) {
		$type = $form['type']['#value'];            
		
		$fields = ipetranslation_node_fields($type);
		// If at least one field is selected for translation
		// also check if content type is translatable
		if (count($fields) > 0) {
			// Check whether the form has "Language neutral" option
			if ($form['language']['#default_value'] == '') {
				$form['language']['#default_value'] = i18n_get_lang();
			}
			$form['language']['#disabled'] = TRUE;
			
			// Clone fields
			foreach ($fields as $field_name) {
				_ipetranslation_clone_field($form, $field_name);
			}                
		}               				
	}
}

/**
 * Clone node field inside form
 * TODO: preserve consistent field layout
 *
 * @param form $form
 * @param string $field_name
 */
function _ipetranslation_clone_field(&$form, $field_name) {
	
	static $node_desc;
	static $languages;
	static $translations;

	// First-time static variables initialization as we assume 
	// only one form and only one node processing per programm execution
	if (($node_desc === null) or ($languages === null)) {
		$node_desc = node_get_types('type', $form['type']['#value']);
		$languages = i18n_language_list();		
	}
	
	// When in the edit mode load available translations
	if (($translations === null) and isset($form['nid']['#value']) and isset($form['tnid']['#value'])) {
		$translations = translation_node_get_translations($form['tnid']['#value']);
		foreach (array_keys($translations) as $tlang) {
			$translations[$tlang] = node_load($translations[$tlang]->nid);
		}
	}

	foreach ($languages as $language => $language_title) {
		switch ($field_name) {				
			case 'body':
                if ($language != $form['language']['#default_value']) {
                    // Adjust weights for teaser and input format
                	$form['body_field']['body']['#weight'] = 1;
                    $form['body_field']['format']['#weight'] = 2;
                    // Clone body and teaser
                    $cloned_field = $form['body_field'];
                    $cloned_field['#after_build'] = array('ipetranslation_teaser_js', 'ipetranslation_teaser_include_verify');
                    $cloned_field['#language'] = $language;
                    $cloned_field['teaser_' . $language . '_include'] = $form['body_field']['teaser_include'];
                    $cloned_field['teaser_' . $language . '_js']      = $form['body_field']['teaser_js'];
                    $cloned_field['teaser_' . $language . '_js']['#teaser']          = 'edit-body-'   . $language;
                    $cloned_field['teaser_' . $language . '_js']['#teaser_checkbox'] = 'edit-teaser-' . $language . '-include';
                    $cloned_field['body_'   . $language]              = $form['body_field']['body'];
                    $cloned_field['format_' . $language]              = $form['body_field']['format'];
                    unset($cloned_field['body']);
                    unset($cloned_field['format']);
                    unset($cloned_field['teaser_include']);
                    unset($cloned_field['teaser_js']);
                    $cloned_field['body_'.$language]['#title'] = 
                        ipetranslation_get_title($node_desc, $field_name, $language, $language_title);
                    if (isset($translations[$language]->{$field_name})) {
                        $cloned_field['body_'.$language]['#default_value'] = 
                            $translations[$language]->{$field_name};
                    }                        
                    $form['body_field_'.$language] = $cloned_field;
                    
                    if (isset($form['#content_extra_fields']['body_field'])) {
                    	$form['#content_extra_fields']['body_field_'.$language] = array(
                    	   'weight' => $form['#content_extra_fields']['body_field']['weight']
                    	);
                    }
                } else {
                    $form['body_field']['body']['#title'] = ipetranslation_get_title($node_desc, $field_name, $language, $language_title);
                }
				break;
				
			default:
				if ($language != $form['language']['#default_value']) {
                    $form[$field_name.'_'.$language] = $form[$field_name];
                    $form[$field_name.'_'.$language]['#title'] = ipetranslation_get_title($node_desc, $field_name, $language, $language_title);
                    if (isset($translations[$language]->{$field_name})) {
                        $form[$field_name.'_'.$language]['#default_value'] = $translations[$language]->{$field_name};
                    }
                    
                    if (isset($form['#content_extra_fields'][$field_name])) {
                        $form['#content_extra_fields'][$field_name.'_'.$language] = array(
                           'weight' => $form['#content_extra_fields'][$field_name]['weight']
                        );
                    }                    
				} else {
					$form[$field_name]['#title'] = ipetranslation_get_title($node_desc, $field_name, $language, $language_title);
				}   				
				break;
		}
    }

  //  $form['#pre_render'][] = 'ipetranslation_clone_extra_weights';
}

// Rewrite of content_alter_extra_weights function from the content module
// Pre-render callback to adjust weights of non-CCK fields
function ipetranslation_clone_extra_weights($elements) {
  if (isset($elements['#content_extra_fields'])) {
  	$cloned_fields = ipetranslation_node_fields($type);
  	$languages = i18n_language_list();      
  	
  	foreach ($elements['#content_extra_fields'] as $key => $value) {
      // Some core 'fields' use a different key in node forms and in 'view'
      // render arrays. Check we're not on a form first.
      if (!isset($elements['#build_id']) && isset($value['view']) && isset($elements[$value['view']])) {
        $elements[$value['view']]['#weight'] = $value['weight'];
      }
      elseif (isset($elements[$key])) {
//        $elements[$key]['#weight'] = $value['weight'];
        $key = $key == 'body' ? 'body_field' : $key;
        if (isset($cloned_fields[$key])) {
        	foreach ($languages as $language => $language_title) {
        		if ($language != $elements['language']['#default_value']) {
        			$elements[$key.'_'.$language]['#weight'] = $value['weight'];
        		}
        	}
        }
      }
    }
  }
  return $elements;	
}

// TODO: Even if title is required in core need to check availability
function ipetranslation_get_title($type, $field, $language, $language_title) {
	switch ($field) {
		case 'title':
			return tt("nodetype:type:$type->type:title_$language", $type->title_label.' on '.$language_title);              
			
		case 'body':
			return tt("nodetype:type:$type->type:body_$language", $type->body_label.' on '.$language_title);              
			
		default:
			return ''; // TODO: Add CCK support
	}	
}

function ipetranslation_teaser_include_verify(&$form, &$form_state) {
    $lang = $form['#language'];
    $message = '';

    // $form['#post'] is set only when the form is built for preview/submit.
    if (isset($form['#post']['body_' . $lang]) && isset($form_state['values']['teaser_' . $lang . '_include']) && !$form_state['values']['teaser_' . $lang . '_include']) {
        // "teaser_include" checkbox is present and unchecked.
        if (strpos($form_state['values']['body_' . $lang], '<!--break-->') === 0) {
            // Teaser is empty string.
            $message = t('You specified that the summary (%lang) should not be shown when this post is displayed in full view. This setting is ignored when the summary is empty.', array('%lang' => $lang));
        }
        elseif (strpos($form_state['values']['body_' . $lang], '<!--break-->') === FALSE) {
            // Teaser delimiter is not present in the body.
            $message = t('You specified that the summary (%lang) should not be shown when this post is displayed in full view. This setting has been ignored since you have not defined a summary for the post. (To define a summary, insert the delimiter "&lt;!--break--&gt;" (without the quotes) in the Body of the post to indicate the end of the summary and the start of the main content.)', array('%lang' => $lang));
        }

        if (!empty($message)) {
            drupal_set_message($message, 'warning');
            // Pass new checkbox value on to preview/submit form processing.
            form_set_value($form['teaser_' . $lang . '_include'], 1, $form_state);
            // Pass new checkbox value back onto form for those cases
            // in which form is redisplayed.
            $form['teaser_include']['#value'] = 1;
        }
    }

  return $form;
}

/**
 * See if the user used JS to submit a teaser.
 */
function ipetranslation_teaser_js(&$form, &$form_state) {
    $lang = $form['#language'];
	
    if (isset($form['#post']['teaser_' . $lang . '_js'])) {
        // Glue the teaser to the body.
        if (trim($form_state['values']['teaser_' . $lang . '_js'])) {
            // Space the teaser from the body
            $body = trim($form_state['values']['teaser_' . $lang . '_js']) ."\r\n<!--break-->\r\n". trim($form_state['values']['body_' . $lang]);
        }
        else {
            // Empty teaser, no spaces.
            $body = '<!--break-->'. $form_state['values']['body_' . $lang];
        }
        // Pass updated body value on to preview/submit form processing.
        form_set_value($form['body_' . $lang], $body, $form_state);
        // Pass updated body value back onto form for those cases
        // in which the form is redisplayed.
        $form['body_' . $lang]['#value'] = $body;
    }
    
    return $form;
}

/**
 * Return Fields selected for In-place translation
 * for the specified content type
 *
 * @param string $type
 * @return array
 */

function ipetranslation_node_fields($type) {
  return variable_get('ipetranslation_'. $type, array());
}

function ipetranslation_node_available_fields($type) {
	
  // Default node fields.
  $fields['node']['#title'] = t('Standard node fields.');
  $options = variable_get('ipetranslation_fields_node', array());
  $options += array(
    'title'  => t('Title'),
    'body'   => t('Body'),
    'author' => t('Author'),
  );

  // If no type defined yet, that's it.
  $fields['node']['#options'] = $options;
  if (!$type) {
    return $fields;
  }

  // Get variable for this node type.
  $fields += variable_get('ipetranslation_fields_node_' . $type, array());

  // Get CCK fields.
  if (($content = module_invoke('content', 'types', $type)) && isset($content['fields'])) {
    // Get context information.
    $info = module_invoke('content', 'fields', NULL, $type);
    $fields['cck']['#title'] = t('CCK fields');
    foreach ($content['fields'] as $name => $data) {
      $fields['cck']['#options'][$data['field_name']] = $data['widget']['label'];
    }
  }

  return $fields;
}